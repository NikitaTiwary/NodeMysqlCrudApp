import {
  Types,
} from 'mongoose';
import {
  Response,
  Request,
  NextFunction,
} from 'express';
import {
  ObjectID,
} from 'bson';
import {
  IApiRequest,
  IApiModel,
} from './types';

import {
  IPopulate,
  IApiParsedQuery,
} from './types/IApiQuery';
import {
  isString,
  toNumber,
} from './helpers';
import {
  IApiDocument,
} from './types/IApiModel';
import ApiController from './api.controller';

const isValidId = Types.ObjectId.isValid;

abstract class BaseController<T extends IApiModel<K, R>, K, R> extends ApiController<T> {
  protected filters: string[];

  constructor(model: T) {
    super(model);
    this.filters = [ 'type', 'deleted' ];
  }

  public index(req: IApiRequest, _res: Response, next: NextFunction): void {
    let query: IApiParsedQuery = {
      deleted: false,
      filter: null,
      limit: 100,
      offset: 0,
      populate: null,
      q: {},
      select: null,
      sort: null,
      total: 0,
    };

    req.modelQuery = this.processQuery(req.query, query);

    if (typeof this.model.parseQuery === 'function') {
      query = this.model.parseQuery(req.modelQuery );
    } else {
      query = this.parseQuery(req.modelQuery );
    }

    query.populate = query.populate ? query.populate : [];

    return this.model.find(query.q)
      .limit(toNumber(query.limit))
      .skip(toNumber(query.offset))
      .sort(query.sort)
      .select(query.select)
      .populate(query.populate)
      .exec((err: any, models: any) => {
        if (err) {
          return next(err);
        } else {
          req.data = models;

          return next();
        }
      });
  }
  public read(
    req: IApiRequest,
    res: Response,
    _next: NextFunction,
  ): Response {
    if (this.hasModel(req.model)) {
      const model = req.model.toObject();

      return res.jsonp(model);
    } else {
      return this.respondModelMissingError(res);
    }
  }
  public create(req: IApiRequest, res: Response, next: NextFunction): void {
    delete req.body._id;
    delete req.body.timestamps;

    // eslint-disable-next-line @typescript-eslint/naming-convention
    const Model = this.model;
    const model = new Model(req.body);
    (<any>model).timestamps = {
      created: {
        by: req.user.username,
      },
    };

    model.save((err, resModel) => {
      if (err) {
        return this.respondValidationError(err, res, next);
      } else {
        res.status(201).json(resModel.toObject());
      }
    });
  }
  public update(
    req: IApiRequest,
    res: Response,
    next: NextFunction,
  ): Response | void {
    if (req.body._id === null) {
      delete req.body._id;
    }
    delete req.body.timestamps;

    if (this.hasModel(req.model)) {
      const model: any = req.model;

      Object.keys(req.body).forEach((key) => {
        model[key] = req.body[key];
      });
      model.timestamps.updated.by = req.user.username;

      model.save((err: any, resModel: IApiDocument) => {
        if (err) {
          return this.respondValidationError(err, res, next);
        } else {
          return res.status(200).json(resModel.toObject());
        }
      });
    } else {
      return this.respondModelMissingError(res);
    }
  }
  public softDelete(
    req: IApiRequest,
    res: Response,
    _next: NextFunction,
  ): Response | void {
    if (this.hasModel(req.model)) {

      // FIXME: potential problem, here someone could inject admin as property,
      // when deleting a user
      const model = req.model;
      model.mark.deleted = true;
      model.timestamps.updated.by = req.user.username;

      model.save((err: any, resModel: IApiDocument) => {
        if (err) {
          return this.respondDeletionError(res, err);
        } else {
          return res.status(200).jsonp(resModel.toObject());
        }
      });
    } else {
      return this.respondModelMissingError(res);
    }
  }
  public delete(
    req: IApiRequest,
    res: Response,
    _next: NextFunction,
  ): Response | void {
    if (this.hasModel(req.model)) {
      const model: any = req.model;
      model.remove((err: any) => {
        if (err) {
          return this.respondDeletionError(res, err);
        } else {
          return res.status(200).jsonp(model.toObject());
        }
      });
    } else {
      return this.respondModelMissingError(res);
    }
  }
  public findById(
    req: IApiRequest,
    res: Response,
    next: NextFunction,
    id: string | number | ObjectID,
    _urlParam?: any,
    populate?: IPopulate[],
  ): Response | void {
    if (isValidId(id)) {
      if (typeof populate === 'undefined') {
        populate = [];
      }

      this.model.findById(id).populate(populate)
        .exec((err, model) => {
          if (err) {
            return this.respondServerError(res, err);
          }
          if (!model) {
            return this.respondNotFound(id, res, this.model.modelName);
          } else {
            req.model = model;

            return next();
          }
        });
    } else {
      return this.respondInvalidId(res);
    }
  }
  public stats(req: IApiRequest, res: Response, next: NextFunction): void {
    this.model.countDocuments((err, result) => {
      if (err) {
        return this.respondServerError(res, err);
      } else {
        if (typeof req.stats !== 'object') {
          req.stats = {};
        }
        req.stats[this.model.collection.name] = result;

        return next();
      }
    });
  }
  public statsResponse(req: IApiRequest, res: Response, _next: NextFunction): Response {
    if (typeof req.stats !== 'object') {
      req.stats = {};
    }

    return res.status(200).json(req.stats);
  }
  public statistics(req: IApiRequest, res: Response, next: NextFunction): void {
    if (typeof this.model.statistics === 'function') {
      const query = req.dateRange || {};
      this.model.statistics(query, (err, result) => {
        if (err) {
          return this.respondServerError(res, err);
        } else {
          if (typeof req.stats !== 'object') {
            req.stats = {};
          }
          req.stats[this.model.collection.name] = result;

          return next();
        }
      });
    } else {
      return this.stats(req, res, next);
    }
  }
  public parseDateRange(
    req: IApiRequest,
    _res: Response,
    next: NextFunction,
    _id: string,
    _urlParam: string,
  ): void {
    // FIXME: this function is called twice for /year/month ....
    const year = parseInt(req.params.year, 10);
    let month = parseInt(req.params.month, 10);
    let toMonth = 12;
    if (!isNaN(year)) {
      if (isNaN(month)) {
        month = 0;
      } else {
        month = Math.max(Math.min(month, 12), 1);
        toMonth = --month + 1;
      }
      let from: Date = new Date();
      from = new Date(from.setFullYear(year, month, 1));
      from = new Date(from.setHours(0, 0, 0, 0));
      let to = new Date(from.valueOf());
      to = new Date(to.setFullYear(year, toMonth, 1));

      if (typeof req.stats !== 'object') {
        req.stats = {};
      }
      req.stats.range = {
        from: from,
        to: to,
      };

      req.dateRange = { $and: [{ date: { $gte: from }}, { date: { $lt: to }}]};
    }

    return next();
  }
  public processQuery(
    query: Request['query'],
    defaultQuery: IApiParsedQuery,
  ): IApiParsedQuery {
    const modelQuery: IApiParsedQuery = {
      offset: 0,
      deleted: false,
      filter: null,
      limit: 100,
      populate: null,
      q: {},
      select: null,
      sort: null,
      total: 0,
    };
    if (typeof query.offset === 'string') {
      modelQuery.offset = this.parsePagination(query.offset, defaultQuery.offset);
    }
    if (typeof query.limit === 'string') {
      modelQuery.limit = this.parsePagination(query.limit, defaultQuery.limit);
    }
    if (typeof query.sort === 'string') {
      modelQuery.sort = this.parseSort(query.sort);
    }
    if (typeof query.filter === 'string') {
      modelQuery.filter = this.parseFilter(query.filter);
    }

    return modelQuery;
  }
  public parseSort(sort: string | null = null): Record<string, -1 | 1> | null {
    if (sort) {
      const parsedSort: Record<string, -1 | 1> = {};
      let _sort: Record<string, string | number> = {};
      try {
        _sort = JSON.parse(sort);

      } catch (e) {
        /* istanbul ignore next */
        if (e.name === 'SyntaxError') {
          _sort = sort.split(' ')
            .filter(s => /^\w+$/.test(s))
            .reduce((acc: any, cur) => {
              acc[cur] = 1;
              return acc;
            }, {});
        }
      }
      Object.entries(_sort).forEach(([ key, value ]) => {
        const order = isString(value) ? parseInt(value, 10) : value;
        parsedSort[key] = isNaN(order) ? 1 : Math.min(Math.max(order, -1), 1) as -1 | 1;
      });

      if (Object.keys(parsedSort).length === 0) {
        parsedSort['date'] = -1;
      }

      return parsedSort;
    } else {
      return null;
    }
  }
  public parseFilter(filterQuery: string | null = null): Record<string, string> {
    let filter: Record<string, string> = {};

    try {
      filter = filterQuery ? JSON.parse(filterQuery.replace(/\'/g, '"')) : {};
    } catch (e) {
      filter = {};
    }

    const allowedFilters: Record<string, string> = {};
    this.filters.forEach(f => {
      if (typeof filter[f] !== 'undefined' && filter[f] !== null) {
        allowedFilters[f] = filter[f].toString();
      }
    });

    return allowedFilters;
  }

  public parsePagination(value: string, defaultValue: string | number): number {
    const _value = toNumber(value);
    const _default = toNumber(defaultValue);

    return isNaN(_value) ? _default : _value;
  }


  public parseQuery(query: IApiParsedQuery): IApiParsedQuery {
    return {
      q: {},
      offset: query.offset,
      limit: query.limit,
      sort: query.sort
        ? {
          ...query.sort,
        }
        : null,
      filter: {
        ...query.filter,
      },
      populate: query.populate
        ? [ ...query.populate ]
        : [],
      deleted: !!query.deleted,
      select: typeof query.select === 'string'
        ? query.select
        : {
          ...query.select,
        },
      total: 0,
    };
  }

}

export default BaseController;
